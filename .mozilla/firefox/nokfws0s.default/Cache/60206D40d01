<!-- This HTML file has been created by texi2html 1.27
     from emacs.texi on 3 March 1994 -->

<TITLE>GNU Emacs Manual - Miscellaneous Commands</TITLE>
<P>Go to the <A HREF="emacs_33.html">previous</A>, <A HREF="emacs_35.html">next</A> section.<P>
<H1><A NAME="SEC308" HREF="emacs_toc.html#SEC308">Miscellaneous Commands</A></H1>
<P>
  This chapter contains several brief topics that do not fit anywhere else.
<P>
<A NAME="IDX1722"></A>
<A NAME="IDX1723"></A>
<H2><A NAME="SEC309" HREF="emacs_toc.html#SEC309">GNUS</A></H2>
<P>
  GNUS is an Emacs subsystem for reading and responding to netnews.  You
can use GNUS to browse through news groups, look at summaries of
articles in specific group, and read articles of interest.  You can
respond to authors or write replies to all the readers of a news group.
<P>
  This section introduces GNUS and describes several basic
features.  Full documentation will appear elsewhere.
<A NAME="IDX1724"></A>
<P>
To start GNUS, type <KBD>M-x gnus <KBD>RET</KBD></KBD>.
<P>
<H3><A NAME="SEC310" HREF="emacs_toc.html#SEC310">GNUS's Three Buffers</A></H3>
<P>
GNUS creates and uses three Emacs buffers, each with its own
particular purpose and its own major mode.
<P>
The <DFN>Newsgroup buffer</DFN> contains a list of newsgroups.  This is the
first buffer that GNUS displays when it starts up.  Normally the list
contains only the newsgroups to which you subscribe (which are listed in
your <TT>`.newsrc'</TT> file) and which contain unread articles.  Use this
buffer to select a specific newsgroup.
<P>
The <DFN>Summary buffer</DFN> lists the articles in a single newsgroup,
including their subjects, their numbers, and who posted them.  GNUS
creates a Summary buffer for a newsgroup when you select the group in
the Newsgroup buffer.  Use this buffer to select an article, and to move
around in an article.
<P>
The <DFN>Article buffer</DFN> displays the text of an article.  You rarely
need to select this buffer because you can read the text while keeping
the Summary buffer selected.
<P>
<H3><A NAME="SEC311" HREF="emacs_toc.html#SEC311">When GNUS Starts Up</A></H3>
<P>
At startup, GNUS reads your <TT>`.newsrc'</TT> news initialization file
and attempts to communicate with the local news server, which is a
repository of news articles.  The news server need not be the same
computer you are logged in on.
<P>
If you start GNUS and connect to the server, but do not see any
newsgroups listed in the Newsgroup buffer, type <KBD>L</KBD> to get a listing
of all the newsgroups.  Then type <KBD>u</KBD> to unsubscribe from particular
newsgroups.  (Move the cursor using <KBD>n</KBD> and <KBD>p</KBD> or the usual
Emacs commands.)
<P>
When you quit GNUS with <KBD>q</KBD>, it automatically records in your
<TT>`.newsrc'</TT> initialization file the subscribed or unsubscribed status
of all newsgroups, except for groups you have "killed".  (You do not
need to edit this file yourself, but you may.)  When new newsgroups come
into existence, GNUS adds them automatically.
<P>
<H3><A NAME="SEC312" HREF="emacs_toc.html#SEC312">Summary of GNUS Commands</A></H3>
<P>
Reading news is a two step process:
<P>
<OL>
<LI>
Choose a newsgroup in the Newsgroup buffer.
<P>
<LI>
Select articles from the Summary buffer.  Each article selected is
displayed in the Article buffer in a large window, below the Summary
buffer in its small window.
</OL>
<P>
Each buffer has commands particular to it, but commands that do the same
things have similar keybindings.  Here are commands for the Newsgroup
and Summary buffers:
<P>
<A NAME="IDX1725"></A>
<A NAME="IDX1726"></A>
<DL COMPACT>
<DT><KBD>z</KBD>
<DD>In the Newsgroup buffer, suspend GNUS.  You can return to GNUS later by
selecting the Newsgroup buffer and typing <KBD>g</KBD> to get newly arrived
articles.
<A NAME="IDX1727"></A>
<A NAME="IDX1728"></A>
<P>
<DT><KBD>q</KBD>
<DD>In the Newsgroup buffer, update your <TT>`.newsrc'</TT> initialization file
and quit GNUS.
<P>
In the Summary buffer, exit the current newsgroup and return to the
Newsgroup buffer.  Thus, typing <KBD>q</KBD> twice quits GNUS.
<A NAME="IDX1729"></A>
<A NAME="IDX1730"></A>
<P>
<DT><KBD>L</KBD>
<DD>In the Newsgroup buffer, list all the newsgroups available on your news
server.  This may be a long list!
<A NAME="IDX1731"></A>
<A NAME="IDX1732"></A>
<P>
<DT><KBD>l</KBD>
<DD>In the Newsgroup buffer, list only the newsgroups to which you subscribe
and which contain unread articles.
<A NAME="IDX1733"></A>
<A NAME="IDX1734"></A>
<A NAME="IDX1735"></A>
<A NAME="IDX1736"></A>
<P>
<DT><KBD>u</KBD>
<DD>In the Newsgroup buffer, unsubscribe from (or subscribe to) the
newsgroup listed in the line that point is on.  When you quit GNUS by
typing <KBD>q</KBD>, GNUS lists your subscribed-to newsgroups in your
<TT>`.newsrc'</TT> file.  The next time you start GNUS, you see only the
newsgroups listed in your <TT>`.newsrc'</TT> file.
<A NAME="IDX1737"></A>
<A NAME="IDX1738"></A>
<P>
<DT><KBD>C-k</KBD>
<DD>In the Newsgroup buffer, "kill" the current line's newsgroup--don't
show it in the Newsgroup buffer from now on.  This affects future GNUS
sessions as well as the present session.
<P>
When you quit GNUS by typing <KBD>q</KBD>, GNUS writes information
in the file <TT>`.newsrc'</TT> describing all newsgroups except those you
have "killed."
<A NAME="IDX1739"></A>
<A NAME="IDX1740"></A>
<P>
<DT><KBD><KBD>SPC</KBD></KBD>
<DD>In the Newsgroup buffer, select the group on the line under the cursor
and display the first unread article in that group.
<A NAME="IDX1741"></A>
<P>
In the Summary buffer, 
<P>
<UL>
<DT><KBD></KBD>
<DD>Select the article on the line under the cursor if none is selected.
<P>
<DT><KBD></KBD>
<DD>Scroll the text of the selected article (if there is one).
<P>
<DT><KBD></KBD>
<DD>Select the next unread article if at the end of the current article.
</UL>
<P>
Thus, you can move through all the articles by repeatedly typing <KBD>SPC</KBD>.
<A NAME="IDX1742"></A>
<P>
<DT><KBD><KBD>DEL</KBD></KBD>
<DD>In the Newsgroup Buffer, move point to the previous newsgroup containing
unread articles.
<A NAME="IDX1743"></A>
<P>
In the Summary buffer, scroll the text of the article backwards.
<A NAME="IDX1744"></A>
<A NAME="IDX1745"></A>
<A NAME="IDX1746"></A>
<P>
<DT><KBD>n</KBD>
<DD>Move point to the next unread newsgroup, or select the next unread
article.
<A NAME="IDX1747"></A>
<A NAME="IDX1748"></A>
<A NAME="IDX1749"></A>
<P>
<DT><KBD>p</KBD>
<DD>Move point to the previous unread newsgroup, or select the previous
unread article.
<A NAME="IDX1750"></A>
<A NAME="IDX1751"></A>
<A NAME="IDX1752"></A>
<A NAME="IDX1753"></A>
<A NAME="IDX1754"></A>
<A NAME="IDX1755"></A>
<A NAME="IDX1756"></A>
<A NAME="IDX1757"></A>
<P>
<DT><KBD>C-n</KBD>
<DD><DT><KBD>C-p</KBD>
<DD>Move point to the next or previous item, even if it is marked as read.
This does not select the article or newsgroup on that line.
<A NAME="IDX1758"></A>
<A NAME="IDX1759"></A>
<P>
<DT><KBD>s</KBD>
<DD>In the Summary buffer, do an incremental search of the current text in
the Article buffer, just as if you switched to the Article buffer and
typed <KBD>C-s</KBD>.
<A NAME="IDX1760"></A>
<A NAME="IDX1761"></A>
<P>
<DT><KBD>M-s <VAR>regexp</VAR> RET</KBD>
<DD>In the Summary buffer, search forward for articles containing a match
for <VAR>regexp</VAR>.
<A NAME="IDX1762"></A>
<A NAME="IDX1763"></A>
<A NAME="IDX1764"></A>
<A NAME="IDX1765"></A>
<P>
<DT><KBD>C-c C-s C-n</KBD>
<DD><DT><KBD>C-c C-s C-s</KBD>
<DD><DT><KBD>C-c C-s C-d</KBD>
<DD><DT><KBD>C-c C-s C-a</KBD>
<DD>In the Summary buffer, sort the list of articles by number, subject,
date, or author.
<A NAME="IDX1766"></A>
<A NAME="IDX1767"></A>
<A NAME="IDX1768"></A>
<A NAME="IDX1769"></A>
<P>
<DT><KBD>C-M-n</KBD>
<DD><DT><KBD>C-M-p</KBD>
<DD>In the Summary buffer, read the next or previous article with the same
subject as the current article.
</DL>
<P>
<A NAME="IDX1770"></A>
<H2><A NAME="SEC313" HREF="emacs_toc.html#SEC313">Sorting Text</A></H2>
<P>
  Emacs provides several commands for sorting text in the buffer.  All
operate on the contents of the region (the text between point and the
mark).  They divide the text of the region into many <DFN>sort records</DFN>,
identify a <DFN>sort key</DFN> for each record, and then reorder the records
into the order determined by the sort keys.  The records are ordered so
that their keys are in alphabetical order, or, for numeric sorting, in
numeric order.  In alphabetic sorting, all upper case letters `A' through
`Z' come before lower case `a', in accord with the ASCII character
sequence.
<P>
  The various sort commands differ in how they divide the text into sort
records and in which part of each record is used as the sort key.  Most of
the commands make each line a separate sort record, but some commands use
paragraphs or pages as sort records.  Most of the sort commands use each
entire sort record as its own sort key, but some use only a portion of the
record as the sort key.
<A NAME="IDX1771"></A>
<A NAME="IDX1772"></A>
<A NAME="IDX1773"></A>
<A NAME="IDX1774"></A>
<A NAME="IDX1775"></A>
<P>
<DL COMPACT>
<DT><KBD>M-x sort-lines</KBD>
<DD>Divide the region into lines, and sort by comparing the entire
text of a line.  A prefix argument means sort into descending order.
<P>
<DT><KBD>M-x sort-paragraphs</KBD>
<DD>Divide the region into paragraphs, and sort by comparing the entire
text of a paragraph (except for leading blank lines).  A prefix
argument means sort into descending order.
<P>
<DT><KBD>M-x sort-pages</KBD>
<DD>Divide the region into pages, and sort by comparing the entire
text of a page (except for leading blank lines).  A prefix
argument means sort into descending order.
<P>
<DT><KBD>M-x sort-fields</KBD>
<DD>Divide the region into lines, and sort by comparing the contents of
one field in each line.  Fields are defined as separated by
whitespace, so the first run of consecutive non-whitespace characters
in a line constitutes field 1, the second such run constitutes field
2, etc.
<P>
Specify which field to sort by with a numeric argument: 1 to sort by
field 1, etc.  A negative argument means sort into descending order.
Thus, minus 2 means sort by field 2 in reverse-alphabetical order.  If
several lines have identical contents in the field being sorted, they
keep same relative order that they had in the original buffer.
<P>
<DT><KBD>M-x sort-numeric-fields</KBD>
<DD>Like <KBD>M-x sort-fields</KBD> except the specified field is converted
to a number for each line, and the numbers are compared.  <SAMP>`10'</SAMP>
comes before <SAMP>`2'</SAMP> when considered as text, but after it when
considered as a number.
<P>
<DT><KBD>M-x sort-columns</KBD>
<DD>Like <KBD>M-x sort-fields</KBD> except that the text within each line
used for comparison comes from a fixed range of columns.  See below
for an explanation.
</DL>
<P>
  For example, if the buffer contains this:
<P>
<PRE>
On systems where clash detection (locking of files being edited) is
implemented, Emacs also checks the first time you modify a buffer
whether the file has changed on disk since it was last visited or
saved.  If it has, you are asked to confirm that you want to change
the buffer.
</PRE>
<P>
then applying <KBD>M-x sort-lines</KBD> to the entire buffer produces this:
<P>
<PRE>
On systems where clash detection (locking of files being edited) is
implemented, Emacs also checks the first time you modify a buffer
saved.  If it has, you are asked to confirm that you want to change
the buffer.
whether the file has changed on disk since it was last visited or
</PRE>
<P>
where the upper case <SAMP>`O'</SAMP> sorts before all lower case letters.  If
you use <KBD>C-u 2 M-x sort-fields</KBD> instead, you get this:
<P>
<PRE>
implemented, Emacs also checks the first time you modify a buffer
saved.  If it has, you are asked to confirm that you want to change
the buffer.
On systems where clash detection (locking of files being edited) is
whether the file has changed on disk since it was last visited or
</PRE>
<P>
where the sort keys were <SAMP>`Emacs'</SAMP>, <SAMP>`If'</SAMP>, <SAMP>`buffer'</SAMP>,
<SAMP>`systems'</SAMP> and <SAMP>`the'</SAMP>.<A NAME="IDX1776"></A>
<P>
  <KBD>M-x sort-columns</KBD> requires more explanation.  You specify the
columns by putting point at one of the columns and the mark at the other
column.  Because this means you cannot put point or the mark at the
beginning of the first line to sort, this command uses an unusual
definition of `region': all of the line point is in is considered part of
the region, and so is all of the line the mark is in.
<P>
  For example, to sort a table by information found in columns 10 to 15,
you could put the mark on column 10 in the first line of the table, and
point on column 15 in the last line of the table, and then run
<CODE>sort-columns</CODE>.  Equivalently, you could run it with the mark on
column 15 in the first line and point on column 10 in the last line.
<P>
  This can be thought of as sorting the rectangle specified by point and
the mark, except that the text on each line to the left or right of the
rectangle moves along with the text inside the rectangle.
See section <A HREF="emacs_14.html#SEC63">Rectangles</A>.
<A NAME="IDX1777"></A>
<P>
  Many of the sort commands ignore case differences when comparing, if
<CODE>sort-fold-case</CODE> is non-<CODE>nil</CODE>.
<P>
<A NAME="IDX1778"></A>
<A NAME="IDX1779"></A>
<H2><A NAME="SEC314" HREF="emacs_toc.html#SEC314">Running Shell Commands from Emacs</A></H2>
<P>
  Emacs has commands for passing single command lines to inferior shell
processes; it can also run a shell interactively with input and output to
an Emacs buffer <SAMP>`*shell*'</SAMP>.
<P>
<DL COMPACT>
<DT><KBD>M-!</KBD>
<DD>Run a specified shell command line and display the output
(<CODE>shell-command</CODE>).
<DT><KBD>M-|</KBD>
<DD>Run a specified shell command line with region contents as input;
optionally replace the region with the output
(<CODE>shell-command-on-region</CODE>).
<DT><KBD>M-x shell</KBD>
<DD>Run a subshell with input and output through an Emacs buffer.
You can then give commands interactively.
</DL>
<P>
<H3><A NAME="SEC315" HREF="emacs_toc.html#SEC315">Single Shell Commands</A></H3>
<A NAME="IDX1780"></A>
<A NAME="IDX1781"></A>
<P>
  <KBD>M-!</KBD> (<CODE>shell-command</CODE>) reads a line of text using the
minibuffer executes it as a shell command in a subshell made just for
this command.  Standard input for the command comes from the null
device.  If the shell command produces any output, the output goes into
an Emacs buffer named <SAMP>`*Shell Command Output*'</SAMP>, which is displayed
in another window but not selected.  A numeric argument, as in <KBD>M-1
M-!</KBD>, directs this command to insert any output into the current
buffer.  In that case, point is left before the output and the mark is
set after the output.
<P>
  If the shell command line ends in <SAMP>`&#38;'</SAMP>, it runs asynchronously.
<A NAME="IDX1782"></A>
<A NAME="IDX1783"></A>
<P>
  <KBD>M-|</KBD> (<CODE>shell-command-on-region</CODE>) is like <KBD>M-!</KBD> but passes
the contents of the region as input to the shell command, instead of no
input.  If a numeric argument is used, meaning insert output in the current
buffer, then the old region is deleted first and the output replaces it as
the contents of the region.<A NAME="IDX1784"></A>
<A NAME="IDX1785"></A>
<P>
  Both <KBD>M-!</KBD> and <KBD>M-|</KBD> use <CODE>shell-file-name</CODE> to specify the
shell to use.  This variable is initialized based on your <CODE>SHELL</CODE>
environment variable when Emacs is started.  If the file name does not
specify a directory, the directories in the list <CODE>exec-path</CODE> are
searched; this list is initialized based on the environment variable
<CODE>PATH</CODE> when Emacs is started.  Your <TT>`.emacs'</TT> file can override
either or both of these default initializations.<P>
  With <KBD>M-!</KBD> and <KBD>M-|</KBD>, Emacs has to wait until the shell
command completes.  To stop waiting, type <KBD>C-g</KBD> to quit; that
also kills the shell command.
<P>
<H3><A NAME="SEC316" HREF="emacs_toc.html#SEC316">Interactive Inferior Shell</A></H3>
<A NAME="IDX1786"></A>
<P>
  To run a subshell interactively, putting its typescript in an Emacs
buffer, use <KBD>M-x shell</KBD>.  This creates (or reuses) a buffer named
<SAMP>`*shell*'</SAMP> and runs a subshell with input coming from and output going
to that buffer.  That is to say, any "terminal output" from the subshell
goes into the buffer, advancing point, and any "terminal input" for
the subshell comes from text in the buffer.  To give input to the subshell,
go to the end of the buffer and type the input, terminated by <KBD>RET</KBD>.
<P>
  Emacs does not wait for the subshell to do anything.  You can switch
windows or buffers and edit them while the shell is waiting, or while it is
running a command.  Output from the subshell waits until Emacs has time to
process it; this happens whenever Emacs is waiting for keyboard input or
for time to elapse.
<P>
  To make multiple subshells, rename the buffer <SAMP>`*shell*'</SAMP> to
something different using <KBD>M-x rename-uniquely</KBD>.  Then type <KBD>M-x
shell</KBD> again to create a new buffer <SAMP>`*shell*'</SAMP> with its own
subshell.  If you rename this buffer as well, you can create a third
one, and so on.  All the subshells run independently and in parallel.
<A NAME="IDX1787"></A>
<A NAME="IDX1788"></A>
<A NAME="IDX1789"></A>
<P>
  The file name used to load the subshell is the value of the variable
<CODE>explicit-shell-file-name</CODE>, if that is non-<CODE>nil</CODE>.  Otherwise, the
environment variable <CODE>ESHELL</CODE> is used, or the environment variable
<CODE>SHELL</CODE> if there is no <CODE>ESHELL</CODE>.  If the file name specified
is relative, the directories in the list <CODE>exec-path</CODE> are searched
(see section <A HREF="emacs_34.html#SEC315">Single Shell Commands</A>).<P>
  As soon as the subshell is started, it is sent as input the contents of
the file <TT>`~/.emacs_<VAR>shellname</VAR>'</TT>, if that file exists, where
<VAR>shellname</VAR> is the name of the file that the shell was loaded from.
For example, if you use <CODE>bash</CODE>, the file sent to it is
<TT>`~/.emacs_bash'</TT>.<A NAME="IDX1790"></A>
<A NAME="IDX1791"></A>
<A NAME="IDX1792"></A>
<P>
  <CODE>cd</CODE>, <CODE>pushd</CODE> and <CODE>popd</CODE> commands given to the inferior
shell are watched by Emacs so it can keep the <SAMP>`*shell*'</SAMP> buffer's
default directory the same as the shell's working directory.  These
commands are recognized syntactically by examining lines of input that are
sent.  If you use aliases for these commands, you can tell Emacs to
recognize them also.  For example, if the value of the variable
<CODE>shell-pushd-regexp</CODE> matches the beginning of a shell command line,
that line is regarded as a <CODE>pushd</CODE> command.  Change this variable when
you add aliases for <SAMP>`pushd'</SAMP>.  Likewise, <CODE>shell-popd-regexp</CODE> and
<CODE>shell-cd-regexp</CODE> are used to recognize commands with the meaning of
<SAMP>`popd'</SAMP> and <SAMP>`cd'</SAMP>.  These commands are recognized only at the
beginning of a shell command line.<A NAME="IDX1793"></A>
<P>
  If Emacs gets an error while trying to handle what it believes is a
<SAMP>`cd'</SAMP>, <SAMP>`pushd'</SAMP> or <SAMP>`popd'</SAMP> command, it runs the hook
<CODE>shell-set-directory-error-hook</CODE> (see section <A HREF="emacs_35.html#SEC337">Hooks</A>).
<A NAME="IDX1794"></A>
<P>
  If Emacs does not properly track changes in the current directory of
the subshell, use the command <KBD>M-x dirs</KBD> to ask the shell what its
current directory is.  This command works for shells that support the
most common command syntax; it may not work for unusual shells.
<P>
<A NAME="IDX1795"></A>
<A NAME="IDX1796"></A>
<H3><A NAME="SEC317" HREF="emacs_toc.html#SEC317">Shell Mode</A></H3>
<P>
  The shell buffer uses Shell mode, which defines several special keys
attached to the <KBD>C-c</KBD> prefix.  They are chosen to resemble the usual
editing and job control characters present in shells that are not under
Emacs, except that you must type <KBD>C-c</KBD> first.  Here is a complete list
of the special key bindings of Shell mode:
<A NAME="IDX1797"></A>
<P>
<DL COMPACT>
<A NAME="IDX1798"></A>
<A NAME="IDX1799"></A>
<DT><KBD><KBD>RET</KBD></KBD>
<DD>At end of buffer send line as input; otherwise, copy current line to end
of buffer and send it (<CODE>comint-send-input</CODE>).  When a line is
copied, any text at the beginning of the line that matches the variable
<CODE>shell-prompt-pattern</CODE> is left out; this variable's value should be
a regexp string that matches the prompts that your shell uses.
<P>
<A NAME="IDX1800"></A>
<A NAME="IDX1801"></A>
<DT><KBD><KBD>TAB</KBD></KBD>
<DD>Complete the command name or file name before point in the shell buffer
(<CODE>comint-dynamic-complete</CODE>).  <KBD>TAB</KBD> also completes history
references; see section <A HREF="emacs_34.html#SEC321">Shell History References</A>.
<P>
<A NAME="IDX1802"></A>
<A NAME="IDX1803"></A>
<DT><KBD>M-?</KBD>
<DD>Display temporarily a list of the possible completions of the file name
before point in the shell buffer
(<CODE>comint-dynamic-list-filename-completions</CODE>).
<P>
<A NAME="IDX1804"></A>
<A NAME="IDX1805"></A>
<DT><KBD>C-a</KBD>
<DD>Move to the beginning of the line, but after the prompt if any
(<CODE>comint-bol</CODE>).
<P>
<A NAME="IDX1806"></A>
<A NAME="IDX1807"></A>
<DT><KBD>C-d</KBD>
<DD>Either delete a character or send EOF
(<CODE>comint-delchar-or-maybe-eof</CODE>).  Typed at the end of the shell
buffer, <KBD>C-d</KBD> sends EOF to the subshell.  Typed at any other
position in the buffer, <KBD>C-d</KBD> deletes a character as usual.
<P>
<A NAME="IDX1808"></A>
<A NAME="IDX1809"></A>
<DT><KBD>C-c C-u</KBD>
<DD>Kill all text pending at end of buffer to be sent as input
(<CODE>comint-kill-input</CODE>).
<P>
<A NAME="IDX1810"></A>
<DT><KBD>C-c C-w</KBD>
<DD>Kill a word before point (<CODE>backward-kill-word</CODE>).
<P>
<A NAME="IDX1811"></A>
<A NAME="IDX1812"></A>
<DT><KBD>C-c C-c</KBD>
<DD>Interrupt the shell or its current subjob if any
(<CODE>comint-interrupt-subjob</CODE>).
<P>
<A NAME="IDX1813"></A>
<A NAME="IDX1814"></A>
<DT><KBD>C-c C-z</KBD>
<DD>Stop the shell or its current subjob if any (<CODE>comint-stop-subjob</CODE>).
<P>
<A NAME="IDX1815"></A>
<A NAME="IDX1816"></A>
<DT><KBD>C-c C-\</KBD>
<DD>Send quit signal to the shell or its current subjob if any
(<CODE>comint-quit-subjob</CODE>).
<P>
<A NAME="IDX1817"></A>
<A NAME="IDX1818"></A>
<DT><KBD>C-c C-o</KBD>
<DD>Kill the last batch of output from a shell command
(<CODE>comint-kill-output</CODE>).  This is useful if a shell command spews
out lots of output that just gets in the way.
<P>
<A NAME="IDX1819"></A>
<A NAME="IDX1820"></A>
<DT><KBD>C-c C-r</KBD>
<DD>Scroll to display the beginning of the last batch of output at the top
of the window; also move the cursor there (<CODE>comint-show-output</CODE>).
<P>
<A NAME="IDX1821"></A>
<A NAME="IDX1822"></A>
<DT><KBD>C-c C-e</KBD>
<DD>Scroll to put the end of the buffer at the bottom of the window
(<CODE>comint-show-maximum-output</CODE>).
<P>
<A NAME="IDX1823"></A>
<A NAME="IDX1824"></A>
<A NAME="IDX1825"></A>
<DT><KBD>C-c C-f</KBD>
<DD>Move forward across one shell command, but not beyond the current line
(<CODE>shell-forward-command</CODE>).  The variable <CODE>shell-command-regexp</CODE>
specifies how to recognize the end of a command.
<P>
<A NAME="IDX1826"></A>
<A NAME="IDX1827"></A>
<DT><KBD>C-c C-b</KBD>
<DD>Move backward across one shell command, but not beyond the current line
(<CODE>shell-backward-command</CODE>).
<P>
<A NAME="IDX1828"></A>
<DT><KBD>M-x dirs</KBD>
<DD>Ask the shell what its current directory is, so that Emacs can agree with 
the shell.
<P>
<A NAME="IDX1829"></A>
<DT><KBD>M-x send-invisible <KBD>RET</KBD> <VAR>text</VAR> <KBD>RET</KBD></KBD>
<DD>Send <VAR>text</VAR> as input to the shell, after reading it without
echoing.  This is useful when a shell command runs a program that asks
for a password.
<P>
<A NAME="IDX1830"></A>
<DT><KBD>M-x comint-continue-subjob</KBD>
<DD>Continue the shell process.  This is useful if you accidentally suspend
the shell process.<A NAME="FOOT2" HREF="emacs_foot.html#FOOT2">(2)</A>
</DL>
<P>
  Shell mode also customizes the paragraph commands so that only shell
promps start new paragraphs.  Thus, a paragraph consists of an input
command plus the output that follows it in the buffer.
<P>
<H3><A NAME="SEC318" HREF="emacs_toc.html#SEC318">Shell Command History</A></H3>
<P>
  Shell buffers support three ways of repeating earlier commands.  You
can use the same keys used in the minibuffer; these work much as they do
in the minibuffer, inserting text from prior commands while point
remains always at the end of the buffer.  You can move through the
buffer to previous inputs in their original place, then resubmit them or
copy them to the end.  Or you can use a <SAMP>`!'</SAMP>-style history
reference.
<P>
<H4><A NAME="SEC319" HREF="emacs_toc.html#SEC319">Shell History Ring</A></H4>
<P>
<A NAME="IDX1831"></A>
<A NAME="IDX1832"></A>
<DL COMPACT>
<DT><KBD>M-p</KBD>
<DD>Fetch the next earlier old shell command.
<A NAME="IDX1833"></A>
<A NAME="IDX1834"></A>
<P>
<DT><KBD>M-n</KBD>
<DD>Fetch the next later old shell command.
<A NAME="IDX1835"></A>
<A NAME="IDX1836"></A>
<A NAME="IDX1837"></A>
<A NAME="IDX1838"></A>
<P>
<DT><KBD>M-r <VAR>regexp</VAR> <KBD>RET</KBD></KBD>
<DD><DT><KBD>M-s <VAR>regexp</VAR> <KBD>RET</KBD></KBD>
<DD>Search backwards or forwards for old shell commands that match <VAR>regexp</VAR>.
</DL>
<P>
  Shell buffers provide a history of previously entered shell commands.  To
reuse shell commands from the history, use the editing commands <KBD>M-p</KBD>,
<KBD>M-n</KBD>, <KBD>M-r</KBD> and <KBD>M-s</KBD>.  These work just like the minibuffer
history commands except that they operate on the text at the end of the
shell buffer, where you would normally insert text to send to the shell.
<P>
  <KBD>M-p</KBD> fetches an earlier shell command to the end of the shell buffer.
Successive use of <KBD>M-p</KBD> fetches successively earlier shell commands,
each replacing any text that was already present as potential shell input.
<KBD>M-n</KBD> does likewise except that it finds successively more recent shell
commands from the buffer.
<P>
  The history search commands <KBD>M-r</KBD> and <KBD>M-s</KBD> read a regular
expression and search through the history for a matching command.  Aside
from the choice of which command to fetch, they work just like <KBD>M-p</KBD>
and <KBD>M-r</KBD>.  If you enter an empty regexp, these commands reuse the
same regexp used last time.
<P>
  When you find the previous input you want, you can resubmit it by
typing <KBD>RET</KBD>, or you can edit it first and then resubmit it if you
wish.
<P>
  These commands get the text of previous shell commands from a special
history list, not from the shell buffer itself.  Thus, editing the shell
buffer, or even killing large parts of it, does not affect the history
that these commands access.
<P>
<H4><A NAME="SEC320" HREF="emacs_toc.html#SEC320">Shell History Copying</A></H4>
<P>
<A NAME="IDX1839"></A>
<A NAME="IDX1840"></A>
<DL COMPACT>
<DT><KBD>C-c C-p</KBD>
<DD>Move point to the previous prompt (<CODE>comint-previous-prompt</CODE>).
<A NAME="IDX1841"></A>
<A NAME="IDX1842"></A>
<P>
<DT><KBD>C-c C-n</KBD>
<DD>Move point to the following prompt (<CODE>comint-next-prompt</CODE>).
<A NAME="IDX1843"></A>
<A NAME="IDX1844"></A>
<P>
<DT><KBD>C-c <KBD>RET</KBD></KBD>
<DD>Copy the input command which point is in, inserting the copy at the end
of the buffer (<CODE>comint-copy-old-input</CODE>).  This is useful if you
move point back to a previous command.  After you copy the command, you
can submit the copy as input with <KBD>RET</KBD>.  If you wish, you can
edit the copy before resubmitting it.
</DL>
<P>
  Moving to a previous input and then copying it with <KBD>C-c
<KBD>RET</KBD></KBD> produces the same results--the same buffer contents--that
you would get by using <KBD>M-p</KBD> enough times to fetch that previous
input from the history list.  However, <KBD>C-c <KBD>RET</KBD></KBD> copies the
text from the buffer, which can be different from what is in the history
list (if you edit the input in the buffer after it has been sent).
<P>
<A NAME="IDX1845"></A>
<H4><A NAME="SEC321" HREF="emacs_toc.html#SEC321">Shell History References</A></H4>
<P>
  Various shells including csh and bash support <DFN>history references</DFN>
that begin with <SAMP>`!'</SAMP> and <SAMP>`^'</SAMP>.  Shell mode now understands this
syntax.  If you insert a history reference and type <KBD>TAB</KBD>, this
searches the input history for a matching command, performs substitution
if necessary, and places the result in the buffer in place of the
history reference.  For example, you can fetch the most recent
command beginning with <SAMP>`mv'</SAMP> with <KBD>! m v <KBD>TAB</KBD></KBD>.  You could
then resubmit this command to the shell by typing <KBD>RET</KBD> as usual.
<P>
<H3><A NAME="SEC322" HREF="emacs_toc.html#SEC322">Shell Mode Options</A></H3>
<A NAME="IDX1846"></A>
<P>
If the variable <CODE>comint-scroll-to-bottom-on-input</CODE> is
non-<CODE>nil</CODE>, insertion and yank commands scroll the selected window
the bottom before inserting.
<A NAME="IDX1847"></A>
<P>
If <CODE>comint-scroll-show-maximum-output</CODE> is non-<CODE>nil</CODE> (which is the
default), then scrolling due to arrival of output tries to place the
last line of text at the bottom line of the window, so as to show as
much useful text as possible.  (This mimics the scrolling behavior of
many terminals.)
<A NAME="IDX1848"></A>
<P>
By setting <CODE>comint-scroll-to-bottom-on-output</CODE>, you can opt for
having point jump to the end of the buffer whenever output arrives--no
matter where in the buffer point was before.  If the value is
<CODE>this</CODE>, point jumps in the selected window.  If the value is
<CODE>all</CODE>, point jumps in each window that shows the comint buffer.  If
the value is <CODE>other</CODE>, point jumps in all nonselected windows that
show the current buffer.  The default value is <CODE>nil</CODE>, which means
point does not jump to the end.
<A NAME="IDX1849"></A>
<P>
The variable <CODE>comint-input-ignoredups</CODE> controls whether successive
identical inputs are stored in the input history.  A non-<CODE>nil</CODE>
value means to omit an input that is the same as the previous input.
The default is <CODE>nil</CODE>, which means to store each input even if it is
equal to the previous input.
<A NAME="IDX1850"></A>
<A NAME="IDX1851"></A>
<A NAME="IDX1852"></A>
<P>
Three variables customize filename completion
<CODE>comint-completion-addsuffix</CODE> controls whether completion inserts a
space or a slash to indicate a fully completed file or directory name
(non-<CODE>nil</CODE> means do insert a space or slash).
<CODE>comint-completion-recexact</CODE>, if non-<CODE>nil</CODE>, directs <KBD>TAB</KBD>
to choose the shortest possible completion if the usual Emacs completion
algorithm cannot add even a single character.
<CODE>comint-completion-autolist</CODE>, if non-<CODE>nil</CODE>, says to list all
the possible completions whenever completion is not exact.
<A NAME="IDX1853"></A>
<P>
Shell mode can optionally expand history references in the buffer when
you send them to the shell.  To request this, set the variable
<CODE>comint-input-autoexpand</CODE> to <CODE>input</CODE>.
<A NAME="IDX1854"></A>
<P>
You can make <KBD>SPC</KBD> perform history expansion by binding <KBD>SPC</KBD> to
the command <CODE>comint-magic-space</CODE>.
<A NAME="IDX1855"></A>
<P>
The command <CODE>comint-dynamic-complete-variable</CODE> does variable name
completion using the environment variables as set within Emacs.  The
variables controlling filename completion apply to variable name
completion too.  This command is normally available through the menu
bar.
<A NAME="IDX1856"></A>
<P>
Command completion normally considers only executable files.
If you set <CODE>shell-command-execonly</CODE> to <CODE>nil</CODE>,
it considers nonexecutable files as well.
<A NAME="IDX1857"></A>
<P>
In a new Shell mode buffer, the input history is initialized from the
file name specified in the variable <CODE>shell-input-ring-file-name</CODE>.
By default, this is <CODE>"~/.history"</CODE>.
<A NAME="IDX1858"></A>
<A NAME="IDX1859"></A>
<A NAME="IDX1860"></A>
<P>
You can now configure the behavior of <SAMP>`pushd'</SAMP>.  Variables control
whether <SAMP>`pushd'</SAMP> behaves like <SAMP>`cd'</SAMP> if no argument is given
(<CODE>shell-pushd-tohome</CODE>), pop rather than rotate with a numeric
argument (<CODE>shell-pushd-dextract</CODE>), and only add directories to the
directory stack if they are not already on it
(<CODE>shell-pushd-dunique</CODE>).  The values you choose should match the
underlying shell, of course.
<P>
<A NAME="IDX1861"></A>
<A NAME="IDX1862"></A>
<A NAME="IDX1863"></A>
<A NAME="IDX1864"></A>
<H2><A NAME="SEC323" HREF="emacs_toc.html#SEC323">Narrowing</A></H2>
<P>
  <DFN>Narrowing</DFN> means focusing in on some portion of the buffer,
making the rest temporarily inaccessible.  The portion which you can
still get to is called the <DFN>accessible portion</DFN>.  Cancelling the
narrowing, and making the entire buffer once again accessible, is called
<DFN>widening</DFN>.  The amount of narrowing in effect in a buffer at any
time is called the buffer's <DFN>restriction</DFN>.
<P>
<DL COMPACT>
<DT><KBD>C-x n n</KBD>
<DD>Narrow down to between point and mark (<CODE>narrow-to-region</CODE>).
<DT><KBD>C-x n w</KBD>
<DD>Widen to make the entire buffer accessible again (<CODE>widen</CODE>).
<DT><KBD>C-x n p</KBD>
<DD>Narrow down to the current page (<CODE>narrow-to-page</CODE>).
</DL>
<P>
  When you have narrowed down to a part of the buffer, that part appears to
be all there is.  You can't see the rest, you can't move into it (motion
commands won't go outside the accessible part), you can't change it in any
way.  However, it is not gone, and if you save the file all the inaccessible
text will be saved.  In addition to sometimes making it easier to
concentrate on a single subroutine or paragraph by eliminating clutter,
narrowing can be used to restrict the range of operation of a replace
command or repeating keyboard macro.  The word <SAMP>`Narrow'</SAMP> appears in the
mode line whenever narrowing is in effect.
<A NAME="IDX1865"></A>
<A NAME="IDX1866"></A>
<P>
  The primary narrowing command is <KBD>C-x n n</KBD> (<CODE>narrow-to-region</CODE>).
It sets the current buffer's restrictions so that the text in the current
region remains accessible but all text before the region or after the region
is invisible.  Point and mark do not change.
<A NAME="IDX1867"></A>
<A NAME="IDX1868"></A>
<P>
  Alternatively, use <KBD>C-x n p</KBD> (<CODE>narrow-to-page</CODE>) to narrow
down to the current page.  See section <A HREF="emacs_25.html#SEC159">Pages</A>, for the definition of a page.
<A NAME="IDX1869"></A>
<A NAME="IDX1870"></A>
<P>
  The way to undo narrowing is to widen with <KBD>C-x n w</KBD> (<CODE>widen</CODE>).
This makes all text in the buffer accessible again.
<P>
  You can get information on what part of the buffer you are narrowed down
to using the <KBD>C-x =</KBD> command.  See section <A HREF="emacs_8.html#SEC27">Cursor Position Information</A>.
<P>
  Because narrowing can easily confuse users who do not understand it,
<CODE>narrow-to-region</CODE> is normally a disabled command.  Attempting to use
this command asks for confirmation and gives you the option of enabling it;
once you enable the command, confirmation will no longer be required for
it.  See section <A HREF="emacs_35.html#SEC353">Disabling Commands</A>.
<P>
<A NAME="IDX1871"></A>
<H2><A NAME="SEC324" HREF="emacs_toc.html#SEC324">Hardcopy Output</A></H2>
<P>
  The Emacs commands for making hardcopy let you print either an entire
buffer or just part of one, either with or without page headers.
See also the hardcopy commands of Dired (see section <A HREF="emacs_19.html#SEC126">Miscellaneous File Operations</A>)
and the diary (see section <A HREF="emacs_33.html#SEC301">Commands Displaying Diary Entries</A>).
<P>
<DL COMPACT>
<DT><KBD>M-x print-buffer</KBD>
<DD>Print hardcopy of current buffer using Unix command <SAMP>`print'</SAMP>
(<SAMP>`lpr -p'</SAMP>).  This makes page headings containing the file name
and page number.
<DT><KBD>M-x lpr-buffer</KBD>
<DD>Print hardcopy of current buffer using Unix command <SAMP>`lpr'</SAMP>.
This makes no page headings.
<DT><KBD>M-x print-region</KBD>
<DD>Like <CODE>print-buffer</CODE> but prints only the current region.
<DT><KBD>M-x lpr-region</KBD>
<DD>Like <CODE>lpr-buffer</CODE> but prints only the current region.
</DL>
<A NAME="IDX1872"></A>
<A NAME="IDX1873"></A>
<A NAME="IDX1874"></A>
<A NAME="IDX1875"></A>
<A NAME="IDX1876"></A>
<P>
  All the hardcopy commands pass extra switches to the <CODE>lpr</CODE>
program based on the value of the variable <CODE>lpr-switches</CODE>.  Its
value should be a list of strings, each string an option starting with
<SAMP>`-'</SAMP>.  For example, to use a printer named <SAMP>`nearme'</SAMP>, set
<CODE>lpr-switches</CODE> like this:
<P>
<PRE>
(setq lpr-switches '("-Pnearme"))
</PRE>
<P>
<A NAME="IDX1877"></A>
<A NAME="IDX1878"></A>
<A NAME="IDX1879"></A>
<H2><A NAME="SEC325" HREF="emacs_toc.html#SEC325">Two-Column Editing</A></H2>
<P>
  Two-column mode lets you conveniently edit two side-by-side columns of
text.  It uses two side-by-side windows, each showing its own
buffer.
<P>
  There are three ways to enter two-column mode:
<P>
<DL COMPACT>
<A NAME="IDX1880"></A>
<A NAME="IDX1881"></A>
<DT><KBD>C-x 6 2</KBD>
<DD>Enter two-column mode with the current buffer on the left, and on the
right, a buffer whose name is based on the current buffer's name
(<CODE>tc-two-columns</CODE>).  If the right-hand buffer doesn't already
exist, it starts out empty; the current buffer's contents are not
changed.
<P>
This command is appropriate when the current buffer contains just one
column and you want to add another column.
<P>
<A NAME="IDX1882"></A>
<A NAME="IDX1883"></A>
<DT><KBD>C-x 6 s</KBD>
<DD>Split the current buffer, which contains two-column text, into two
buffers, and display them side by side (<CODE>tc-split</CODE>).  The current
buffer becomes the left-hand buffer, but the text in the right-hand
column is moved into the right-hand buffer.  The current column
specifies the split point.  Splitting starts with the current line and
continues to the end of the buffer.
<P>
This command is appropriate when you have a buffer that already contains
two-column text, and you wish to separate the columns temporarily.
<P>
<A NAME="IDX1884"></A>
<A NAME="IDX1885"></A>
<DT><KBD>C-x 6 b <VAR>buffer</VAR> <KBD>RET</KBD></KBD>
<DD>Enter two-column mode using the current buffer as the left-hand buffer,
and using buffer <VAR>buffer</VAR> as the right-hand buffer
(<CODE>tc-associate-buffer</CODE>).
</DL>
<P>
  <KBD>C-x 6 s</KBD> looks for a column separator which is a string that
appears on each line between the two columns.  You can specify the width
of the separator with a numeric argument to <KBD>C-x 6 s</KBD>; that many
characters, before point, constitute the separator string.  By default,
the width is 1, so the column separator is the character before point.
<P>
  When a line has the separator at the proper place, <KBD>C-x 6 s</KBD> puts
the text after the separator into the right-hand buffer, and deletes the
separator.  Lines that don't have the column separator at the proper
place remain unsplit; they stay in the left-hand buffer, and the
right-hand buffer gets an empty line to correspond.  (This is the way
to write a line which "spans both columns while in two-column mode:
write it in the left-hand buffer, and put an empty line in the right-hand
buffer.)
<P>
  It's not a good idea to use ordinary scrolling commands during
two-column editing, because that separates the two parts of each split
line.  Instead, use these special scroll commands:
<P>
<DL COMPACT>
<A NAME="IDX1886"></A>
<A NAME="IDX1887"></A>
<DT><KBD>C-x 6 <KBD>SPC</KBD></KBD>
<DD>Scroll both buffers up, in lockstep (<CODE>tc-scroll-up</CODE>).
<A NAME="IDX1888"></A>
<A NAME="IDX1889"></A>
<DT><KBD>C-x 6 <KBD>DEL</KBD></KBD>
<DD>Scroll both buffers down, in lockstep (<CODE>tc-scroll-down</CODE>).
<A NAME="IDX1890"></A>
<A NAME="IDX1891"></A>
<DT><KBD>C-x 6 C-l</KBD>
<DD>Recenter both buffers, in lockstep (<CODE>tc-recenter</CODE>).
</DL>
<A NAME="IDX1892"></A>
<A NAME="IDX1893"></A>
<P>
  When you have edited both buffers as you wish, merge them with
<KBD>C-x 6 1</KBD> (<CODE>tc-merge</CODE>).  This copies the text from the
right-hand buffer as a second column in the other buffer.  To go back to
two-column editing, use <KBD>C-x 6 s</KBD>.
<A NAME="IDX1894"></A>
<A NAME="IDX1895"></A>
<P>
  Use <KBD>C-x 6 d</KBD> to disassociate the two buffers, leaving each as it
stands (<CODE>tc-dissociate</CODE>).  If the other buffer, the one not current
when you type <KBD>C-x 6 d</KBD>, is empty, <KBD>C-x 6 d</KBD> kills it.
<P>
<H2><A NAME="SEC326" HREF="emacs_toc.html#SEC326">Editing Binary Files</A></H2>
<A NAME="IDX1896"></A>
<A NAME="IDX1897"></A>
<P>
  There is a special major mode for editing binary files: Hexl mode.  To
use it, use <KBD>M-x hexl-find-file</KBD> instead of <KBD>C-x C-f</KBD> to visit
the file.  This command converts the file's contents to hexadecimal and
lets you edit the translation.  When you save the file, it is converted
automatically back to binary.
<P>
  You can also use <KBD>M-x hexl-mode</KBD> to translate an existing buffer
into hex.  This is useful if you visit a file normally and then discover
it is a binary file.
<P>
  Ordinary text characters overwrite in Hexl mode.  This is to reduce
the risk of accidentally spoiling the alignment of data in the file.
There are special commands for insertion.  Here is a list of the
commands of Hexl mode:
<P>
<DL COMPACT>
<DT><KBD>C-M-d</KBD>
<DD>Insert a byte with a code typed in decimal.
<P>
<DT><KBD>C-M-o</KBD>
<DD>Insert a byte with a code typed in octal.
<P>
<DT><KBD>C-M-x</KBD>
<DD>Insert a byte with a code typed in hex.
<P>
<DT><KBD>C-x [</KBD>
<DD>Move to the beginning of a 1k-byte "page".
<P>
<DT><KBD>C-x ]</KBD>
<DD>Move to the end of a 1k-byte "page".
<P>
<DT><KBD>M-g</KBD>
<DD>Move to an address specified in hex.
<P>
<DT><KBD>M-j</KBD>
<DD>Move to an address specified in decimal.
<P>
<DT><KBD>C-c C-c</KBD>
<DD>Leave Hexl mode, going back to the major mode this buffer had before you
invoked <CODE>hexl-mode</CODE>.
</DL>
<P>
<A NAME="IDX1898"></A>
<A NAME="IDX1899"></A>
<A NAME="IDX1900"></A>
<A NAME="IDX1901"></A>
<A NAME="IDX1902"></A>
<H2><A NAME="SEC327" HREF="emacs_toc.html#SEC327">Using Emacs as a Server</A></H2>
<P>
  Various programs such as <CODE>mail</CODE> can invoke your choice of editor
to edit a particular piece of text, such as a message that you are
sending.  By convention, these programs use the environment variable
<CODE>EDITOR</CODE> to specify which editor to run.  If you set <CODE>EDITOR</CODE>
to <SAMP>`emacs'</SAMP>, they invoke Emacs--but in an inconvenient fashion, by
starting a new, separate Emacs process.  This is inconvenient because it
takes time and because the new Emacs process doesn't share the buffers
in the existing Emacs process.
<P>
  You can arrange to use your existing Emacs process as the editor for
programs like <CODE>mail</CODE> by using the Emacs client and Emacs server
programs.  Here is how.
<P>
  First, the preparation.  Within Emacs, call the function
<CODE>server-start</CODE>.  (Your <TT>`.emacs'</TT> file can do this automatically
if you add the expression <CODE>(server-start)</CODE> to it.)  Then, outside
Emacs, set the <CODE>EDITOR</CODE> environment variable to
<SAMP>`emacsclient'</SAMP>.
<A NAME="IDX1903"></A>
<A NAME="IDX1904"></A>
<P>
  Then, whenever any program invokes your specified <CODE>EDITOR</CODE>
program, the effect is to send a message to your principal Emacs telling
it to visit a file.  (That's what the program <CODE>emacsclient</CODE> does.)
Emacs obeys silently; it does not immediately switch to the new file's
buffer.  When you want to do that, type <KBD>C-x #</KBD>
(<CODE>server-edit</CODE>).
<P>
  When you've finished editing that buffer, type <KBD>C-x #</KBD> again.
This saves the file and sends a message back to the <CODE>emacsclient</CODE>
program telling it to exit.  The programs that use <CODE>EDITOR</CODE> wait
for the "editor" (actually, <CODE>emacsclient</CODE>) to exit.  <KBD>C-x #</KBD>
also checks to see if any other files are pending for you to edit, and
selects the next one.
<P>
  You can switch to a server buffer manually if you wish; you don't have
to arrive at it with <KBD>C-x #</KBD>.  But <KBD>C-x #</KBD> is the only way to
say that you are "finished" with one.
<A NAME="IDX1905"></A>
<P>
  If you set the variable <CODE>server-window</CODE> to a window or a frame,
<KBD>C-x #</KBD> displays the server buffer in that window or in that frame.
<P>
  While <CODE>mail</CODE> or another application is waiting for
<CODE>emacsclient</CODE> to finish, <CODE>emacsclient</CODE> does not read terminal
input.  So the terminal that <CODE>mail</CODE> was using is effectively
blocked for the duration.  In order to edit with your principal Emacs,
you need to be able to use it without using that terminal.  There are
two ways to do this:
<P>
<UL>
<LI>
Using a window system, run <CODE>mail</CODE> and the principal Emacs in two
separate windows.  While <CODE>mail</CODE> is waiting for <CODE>emacsclient</CODE>,
the window where it was running is blocked, but you can use Emacs by
switching windows.
<P>
<LI>
Use Shell mode in Emacs to run the other program such as <CODE>mail</CODE>;
then, <CODE>emacsclient</CODE> blocks only the subshell under Emacs; you can
still use Emacs to edit the file.
</UL>
<A NAME="IDX1906"></A>
<P>
  Some programs write temporary files for you to edit.  After you edit
the temporary file, the program reads it back and deletes it.  If the
Emacs server is later asked to edit the same file name, it should assume
this has nothing to do with the previous occasion for that file name.
The server accomplishes this by killing the temporary file's buffer when
you finish with the file.  Use the variable
<CODE>server-temp-file-regexp</CODE> to specify which files are temporary in
this sense; its value should be a regular expression that matches file
names that are temporary.
<P>
<A NAME="IDX1907"></A>
<A NAME="IDX1908"></A>
<H2><A NAME="SEC328" HREF="emacs_toc.html#SEC328">Recursive Editing Levels</A></H2>
<P>
  A <DFN>recursive edit</DFN> is a situation in which you are using Emacs
commands to perform arbitrary editing while in the middle of another
Emacs command.  For example, when you type <KBD>C-r</KBD> inside of a
<CODE>query-replace</CODE>, you enter a recursive edit in which you can change
the current buffer.  On exiting from the recursive edit, you go back to
the <CODE>query-replace</CODE>.
<A NAME="IDX1909"></A>
<A NAME="IDX1910"></A>
<A NAME="IDX1911"></A>
<P>
  <DFN>Exiting</DFN> the recursive edit means returning to the unfinished
command, which continues execution.  To exit, type <KBD>C-M-c</KBD>
(<CODE>exit-recursive-edit</CODE>).
<P>
  You can also <DFN>abort</DFN> the recursive edit.  This is like exiting, but
also quits the unfinished command immediately.  Use the command <KBD>C-]</KBD>
(<CODE>abort-recursive-edit</CODE>) for this.  See section <A HREF="emacs_36.html#SEC362">Quitting and Aborting</A>.
<P>
  The mode line shows you when you are in a recursive edit by displaying
square brackets around the parentheses that always surround the major and
minor mode names.  Every window's mode line shows this, in the same way,
since being in a recursive edit is true of Emacs as a whole rather than
any particular window or buffer.
<P>
  It is possible to be in recursive edits within recursive edits.  For
example, after typing <KBD>C-r</KBD> in a <CODE>query-replace</CODE>, you may type a
command that enters the debugger.  This begins a recursive editing level
for the debugger, within the recursive editing level for <KBD>C-r</KBD>.
Mode lines display a pair of square brackets for each recursive editing
level currently in progress.
<P>
  Exiting the inner recursive edit (such as, with the debugger <KBD>c</KBD>
command) resumes the command running in the next level up.  When that
command finishes, you can then use <KBD>C-M-c</KBD> to exit another recursive
editing level, and so on.  Exiting applies to the innermost level only.
Aborting also gets out of only one level of recursive edit; it returns
immediately to the command level of the previous recursive edit.  If you
wish, you can then abort the next recursive editing level.
<P>
  Alternatively, the command <KBD>M-x top-level</KBD> aborts all levels of
recursive edits, returning immediately to the top level command reader.
<P>
  The text being edited inside the recursive edit need not be the same text
that you were editing at top level.  It depends on what the recursive edit
is for.  If the command that invokes the recursive edit selects a different
buffer first, that is the buffer you will edit recursively.  In any case,
you can switch buffers within the recursive edit in the normal manner (as
long as the buffer-switching keys have not been rebound).  You could
probably do all the rest of your editing inside the recursive edit,
visiting files and all.  But this could have surprising effects (such as
stack overflow) from time to time.  So remember to exit or abort the
recursive edit when you no longer need it.
<P>
  In general, we try to minimize the use of recursive editing levels in
GNU Emacs.  This is because they constrain you to "go back" in a
particular order--from the innermost level toward the top level.  When
possible, we present different activities in separate buffers.  Some
commands switch to a new major mode but provide a way to switch back.
These approaches give you more flexibility to go back to unfinished
tasks in the order you choose.
<P>
<H2><A NAME="SEC329" HREF="emacs_toc.html#SEC329">Dissociated Press</A></H2>
<A NAME="IDX1912"></A>
<P>
  <KBD>M-x dissociated-press</KBD> is a command for scrambling a file of text
either word by word or character by character.  Starting from a buffer of
straight English, it produces extremely amusing output.  The input comes
from the current Emacs buffer.  Dissociated Press writes its output in a
buffer named <SAMP>`*Dissociation*'</SAMP>, and redisplays that buffer after every
couple of lines (approximately) to facilitate reading it.
<P>
  Dissociated Press asks every so often whether to continue operating.
Answer <KBD>n</KBD> to stop it.  You can also stop at any time by typing
<KBD>C-g</KBD>.  The dissociation output remains in the <SAMP>`*Dissociation*'</SAMP>
buffer for you to copy elsewhere if you wish.
<A NAME="IDX1913"></A>
<P>
  Dissociated Press operates by jumping at random from one point in the
buffer to another.  In order to produce plausible output rather than
gibberish, it insists on a certain amount of overlap between the end of
one run of consecutive words or characters and the start of the next.
That is, if it has just printed out `president' and then decides to jump
to a different point in the file, it might spot the `ent' in `pentagon'
and continue from there, producing `presidentagon'.<A NAME="FOOT3" HREF="emacs_foot.html#FOOT3">(3)</A>  Long sample texts produce the best results.
<A NAME="IDX1914"></A>
<P>
  A positive argument to <KBD>M-x dissociated-press</KBD> tells it to operate
character by character, and specifies the number of overlap characters.  A
negative argument tells it to operate word by word and specifies the number
of overlap words.  In this mode, whole words are treated as the elements to
be permuted, rather than characters.  No argument is equivalent to an
argument of two.  For your againformation, the output goes only into the
buffer <SAMP>`*Dissociation*'</SAMP>.  The buffer you start with is not changed.
<A NAME="IDX1915"></A>
<A NAME="IDX1916"></A>
<A NAME="IDX1917"></A>
<P>
  Dissociated Press produces nearly the same results as a Markov chain
based on a frequency table constructed from the sample text.  It is,
however, an independent, ignoriginal invention.  Dissociated Press
techniquitously copies several consecutive characters from the sample
between random choices, whereas a Markov chain would choose randomly for
each word or character.  This makes for more plausible sounding results,
and runs faster.
<A NAME="IDX1918"></A>
<A NAME="IDX1919"></A>
<A NAME="IDX1920"></A>
<A NAME="IDX1921"></A>
<A NAME="IDX1922"></A>
<A NAME="IDX1923"></A>
<P>
  It is a mustatement that too much use of Dissociated Press can be a
developediment to your real work.  Sometimes to the point of outragedy.
And keep dissociwords out of your documentation, if you want it to be well
userenced and properbose.  Have fun.  Your buggestions are welcome.
<P>
<A NAME="IDX1924"></A>
<A NAME="IDX1925"></A>
<A NAME="IDX1926"></A>
<A NAME="IDX1927"></A>
<A NAME="IDX1928"></A>
<A NAME="IDX1929"></A>
<H2><A NAME="SEC330" HREF="emacs_toc.html#SEC330">Other Amusements</A></H2>
<P>
  If you are a little bit bored, you can try <KBD>M-x hanoi</KBD>.  If you are
considerably bored, give it a numeric argument.  If you are very very
bored, try an argument of 9.  Sit back and watch.
<A NAME="IDX1930"></A>
<P>
  If you want a little more personal involvement, try <KBD>M-x gomoku</KBD>,
which plays the game Go Moku with you.
<A NAME="IDX1931"></A>
<A NAME="IDX1932"></A>
<A NAME="IDX1933"></A>
<P>
  <KBD>M-x blackbox</KBD> and <KBD>M-x mpuz</KBD> are two kinds of puzzles.
<CODE>blackbox</CODE> challenges you to determine the location of objects
inside a box by tomography.  <CODE>mpuz</CODE> displays a multiplication
puzzle with letters standing for digits in a code that you must
guess--to guess a value, type a letter and then the digit you think it
stands for.
<A NAME="IDX1934"></A>
<P>
  <KBD>M-x dunnet</KBD> runs an adventure-style exploration game, which is
a bigger sort of puzzle.
<P>
  When you are frustrated, try the famous Eliza program.  Just do
<KBD>M-x doctor</KBD>.  End each input by typing <KBD>RET</KBD> twice.
<A NAME="IDX1935"></A>
<P>
  When you are feeling strange, type <KBD>M-x yow</KBD>.
<P>
<A NAME="IDX1936"></A>
<A NAME="IDX1937"></A>
<A NAME="IDX1938"></A>
<A NAME="IDX1939"></A>
<H2><A NAME="SEC331" HREF="emacs_toc.html#SEC331">Emulation</A></H2>
<P>
  GNU Emacs can be programmed to emulate (more or less) most other
editors.  Standard facilities can emulate these:
<P>
<DL COMPACT>
<A NAME="IDX1940"></A>
<A NAME="IDX1941"></A>
<DT>EDT (DEC VMS editor)
<DD>Turn on EDT emulation with <KBD>M-x edt-emulation-on</KBD>.  <KBD>M-x
edt-emulation-off</KBD> restores normal Emacs command bindings.
<P>
Most of the EDT emulation commands are keypad keys, and most standard
Emacs key bindings are still available.  The EDT emulation rebindings
are done in the global keymap, so there is no problem switching
buffers or major modes while in EDT emulation.
<P>
<A NAME="IDX1942"></A>
<A NAME="IDX1943"></A>
<DT>Gosling Emacs
<DD>To turn on emulation of Gosling Emacs (alias Unipress Emacs), type the
command <KBD>M-x set-gosmacs-bindings</KBD>.  This redefines many keys,
mostly on the <KBD>C-x</KBD> and <KBD>ESC</KBD> prefixes, to work as they do in
Gosmacs.  <KBD>M-x set-gnu-bindings</KBD> returns to normal GNU Emacs by
rebinding the same keys to the definitions they had before you used
<KBD>M-x set-gosmacs-bindings</KBD>.
<P>
<A NAME="IDX1944"></A>
<DT>vi (Berkeley Unix editor)
<DD>Turn on vi emulation with <KBD>M-x vi-mode</KBD>.  This is a major mode
that replaces the previously established major mode.  All of the
vi commands that, in real vi, enter "input" mode are programmed
in the Emacs emulator to return to the previous major mode.  Thus,
ordinary Emacs serves as vi's "input" mode.
<P>
Because vi emulation works through major modes, it does not work
to switch buffers during emulation.  Return to normal Emacs first.
<P>
If you plan to use vi emulation much, you probably want to bind a key
to the <CODE>vi-mode</CODE> command.
<P>
<A NAME="IDX1945"></A>
<DT>vi (alternate emulator)
<DD>Another vi emulator said to resemble real vi more thoroughly is
invoked by <KBD>M-x vip-mode</KBD>.  "Input" mode in this emulator is
changed from ordinary Emacs so you can use <KBD>ESC</KBD> to go back to
emulated vi command mode.  To get from emulated vi command mode back
to ordinary Emacs, type <KBD>C-z</KBD>.
<P>
This emulation does not work through major modes, and it is possible
to switch buffers in various ways within the emulator.  It is not
so necessary to assign a key to the command <CODE>vip-mode</CODE> as
it is with <CODE>vi-mode</CODE> because terminating insert mode does
not use it.
<P>
For full information, see the long comment at the beginning of the
source file, which is <TT>`lisp/vip.el'</TT> in the Emacs distribution.
</DL>
<P>
I am interested in hearing which vi emulator users prefer, as well as in
receiving more complete user documentation for either or both emulators.
Warning: loading both at once may cause name conflicts; no one has checked.
<P>Go to the <A HREF="emacs_33.html">previous</A>, <A HREF="emacs_35.html">next</A> section.<P>
